---
title: Java 多线程程序的性能调校
date: 2019-09-13 23:25:54
categories: [开发,多线程]
tags: [Java,多线程]
---

> 本文摘抄自《Java 多线程编程实战指南》核心篇 第十二章小结

**本章介绍了与 Java 多线程程序紧密相关的性能调校常用技术。**

---

&emsp;&emsp;Java 虚拟机自 Java 6 开始对内部锁进行了若干优化：锁消除、锁粗化、偏向锁以及适应性锁。除锁消除是 Java 7 开始引入的，其他优化均是在 Java 6 开始引入的，**这些优化仅在 Java 虚拟机的 server 模式下起作用。这些优化默认都是开启的，且多数优化都可能依赖于 JIT 的内联优化，并且其本身也可能是通过 JIT 编译实现的。**因此，这些优化都有其开销。锁消除优化能够彻底消除锁的开销，它依赖于逃逸分析技术。锁粗化优化能够减少线程申请/释放锁的频率，其代价是使临界区长度变大，从而可能导致线程在申请锁时的等待时间变长。偏向锁优化可以减小锁的申请/释放的开销，它不适用于争用程度较高的锁。适应性锁优化可以减小锁申请的开销，有利于减少上下文切换。

&emsp;&emsp;**锁的开销主要是由争用锁引起的。**这些开销主要包括：上下文切换与线程调度开销、内存同步、编译器优化受限的开销以及限制可伸缩性。降低锁的开销可以从使用锁的替代品、降低锁的争用程度以及减少线程所需申请的锁的数量这几个方面入手。

&emsp;&emsp;使用可参数化锁可以减少线程所需申请的锁的数量从而降低锁的开销，但是它在一定程度上破坏了封装性。

&emsp;&emsp;减小临界区的长度可以减少锁的持有时间，从而降低锁的争用程度。减小临界区的长度有利于适用性锁优化发挥作用。在不影响线程安全的前提下，将临界区中的阻塞式 I/O 等阻塞操作以及较耗时的操作挪动到临界区之外可以减小临界区的长度。

&emsp;&emsp;减小锁的粒度可以降低锁的申请频率从而降低锁的争用程度。减小锁的粒度常用技术包括锁拆分技术和锁分段技术。锁拆分技术在高争用情况下的效果可能并不明显；锁分段技术会使得对整个对象进行加锁比较困难乃至不可能。

&emsp;&emsp;减少上下文切换可以从这几个方面入手：控制线程数量、避免在临界区中执行阻塞式 I/O 等阻塞操作、避免在临界区中执行比较耗时的操作和减少 Java 虚拟机垃圾回收。

&emsp;&emsp;运用多线程设计模式也有助于提升多线程程序的性能，但是程序的复杂性也可能相应增加。

&emsp;&emsp;**伪共享产生的前提是多个线程访问被缓存到同一个缓存中的不同变量，它会导致大量的缓存未命中，从而增加内存访问操作的开销。**了解 Java 对象的内存布局有助于分析与消除伪共享。Java 对象内存布局的规则包括：对象是以 8 字节为粒度进行对齐的、对象中的实例字段并非依照其源代码声明顺序排列以及继承自父类的实例字段不会与类本身定义的实例字段混杂在一起进行存储等。使用 jol 工具可以查看具体对象的内存布局情况。判断伪共享是否存在可以从分析多个线程是否存在共同的共享变量入手，并通过 jol 以及 Linux 内核工具 perf 来进一步分析与确认。**伪共享可通过手工填充、自动填充以及降低共享变量的访问频率这几个方面来消除与规避。**手工填充和自动填充可以在无须调整程序算法的前提下消除伪共享。手工填充的缺点比较多，使用该方法我们必须知道缓存行的宽度、Java 对象的具体内存布局，这使得该方法存在硬件、软件层面的可移植性问题，并对人员的要求比较高。并且，我们还需要避免手工填充的字段被 Java 虚拟机优化掉，自动填充依赖于 `@Contented` 注解，它避免了手工填充的缺点，但是其消耗的额外空间更多。Java 虚拟机对自动填充的支持需要通过 Java 虚拟机的开关 "-XX:-RestrictContended" 开启。虽然减少共享变量的访问频率所带来的效果可能比较明显，但是由于它可能涉及程序算法的调整，因此其适用范围比较有限。

![本章知识结构图](https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/Multithreading/Multithreading-Chapter-Twelve.png) 