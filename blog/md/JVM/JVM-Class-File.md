---
title: JVM 之类文件结构
date: 2018-11-24 14:35:58
categories: [开发,JVM]
tags: [Java,JVM]
---

> 代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步，却是编程语言发展的一大步。

## 无关性的基石
实现语言无关性的基础是虚拟机和字节码存储格式。Java 虚拟机不和包括 Java 在内的任何语言绑定，它只与“Class 文件”这种特定的二进制文件格式所关联，Class 文件中包含了 Java 虚拟机指令集和符号表以及若干其他辅助信息。

基于安全方面的考虑，Java 虚拟机规范要求在 Class 文件中使用许多强制性的语法和结构化约束，**但任一门功能性语言都可以表示为一个能被 Java 虚拟机所接受的有效的 Class 文件。**

![Java 虚拟机提供的语言无关性](https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/JVM/JVM-language-unrelated.png)

Java 语言的各种变量、关键字和运算符号的语义最终都是由多条字节码命令组合而成的。

## Class 类文件的结构
Class 文件是一组以 8 位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在 Class 文件之中，中间没有添加任何分隔符，这使得整个 Class 文件中存储的内容几乎全是程序运行的必要数据，没有空隙存在。

根据 Java 虚拟机规范的规定，Class 文件格式采用一种类似于 C 语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：**无符号数和表**。

- 无符号数：属于基本的数据类型，以 u1、u2、u4、u8 来分别代表 1 个字节、2 个字节、4 个字节和 8 个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照 UTF-8 编码构成字符串值。
- 表：是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性地以“_info”结尾。表用于描述有层次关系的复合结构的数据，整个 Class 文件本质上就是一张表。

（这里有关的详细介绍还是请看《深入理解 Java 虚拟机》中的第六章节）

### 魔数与 Class 文件的版本
每个 Class 文件的头 4 个字节称为魔数，它的唯一作用是 **确定这个文件是否为一个能被虚拟机接受的 Class 文件。**

Class 文件的魔数的获得很有“浪漫气息”，值为：0xCAFEBABE（咖啡宝贝……）

紧接着魔数的 4 个字节存储的是 Class 文件的版本号：第 5 和第 6 个字节是次版本号，第 7 和第 8 个字节是主版本号。

### 常量池
紧接着主次版本号之后的是常量池入口，常量池可以理解为 Class 文件之中的资源仓库，它是 Class 文件结构中与其他项目关联最多的数据类型，也是占用 Class 文件空间最大的数据项目之一，同时它还是在 Class 文件中第一个出现的表类型数据项目。

由于常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项 u2 类型的数据，代表常量池容量计数值。**与 Java 中语言习惯不一样的是，这个容量计数是从 1 开始而不是 0。**

在 Class 文件格式规范制定之时，设计者将第 0 项常量空出来是为了满足后面某些指向常量池的索引值的数据在特定情况下需要表达“不引用任何一个常量池项目”的含义，这种情况就可以把索引值置为 0 来表示。

**常量池主要存放两大类常量：字面量和符号引用。**

字面量比较接近于 Java 语言层面的常量概念，比如文本字符串、声明为 final 的常量值等。

而符号引用则属于编译原理方面的概念，包括了下面三类常量：

- 类和接口的全限定名
- 字段的名称和描述符
- 方法的名称和描述符

在 Class 文件中不会保存各个方法、字段的最终内存布局信息，因此这些字段、方法的符号引用不经过运行期转换的话无法得到真正的内存入口地址，也就无法直接被虚拟机使用。

当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中。

![附上手稿](https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/JVM/VM-06.jpg)

### 访问标志
在常量池结束之后，紧接着的两个字节代表访问标志，这个标志用于识别一些类或者接口层次的访问信息，包括：

- 这个 Class 是类还是接口
- 是否定义为 public 类型
- 是否定义为 abstract 类型
- 如果是类的话，是否被声明为 final
- .....

### 类索引、父类索引与接口索引集合
类索引和父类索引都是一个 u2 类型的数据，而接口索引集合是一组 u2 类型的数据的集合，Class 文件中由这三项数据来确定这个类的继承关系。

类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名。

由于 Java 语言不允许多重继承，所以父类索引只有一个，**除了 java.lang.Object 之外，所有的 Java 类都有父类**，因此除了 java.lang.Object 外，所有 Java 类的父类索引都不为 0。

接口索引集合就用来描述这个类实现了哪些接口，这些被实现的接口将按 implements 语句（如果这个类本身是一个接口，则应当是 extends 语句）后的接口顺序从左到右排列在接口索引集合中。

### 字段表集合
字段表用于描述接口或者类中声明的变量。

字段包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量。

字段表集合中不会列出从超类或者父类接口中继承而来的字段，但有可能列出原本 Java 代码之中不存在的字段，譬如在内部类中为了保持对外部类的访问性，会自动添加指向外部类实例的字段。

**另外，在 Java 语言中字段是无法重载的，两个字段的数据类型、修饰符不管是否相同，都必须使用不一样的名称，但是对于字节码来讲，如果两个字段的描述符不一致，那字段重名就是合法的。**

### 方法表集合
方法表的结构如同字段表一样，依次包括了访问标志、名称索引、描述符索引、属性表集合几项。

方法里的 Java 代码，经过编译器编译成字节码指令后，存放在方法属性表集合中一个名为“Code”的属性里面。

与字段表集合相对应的，如果父类方法在子类中没有被重写，方法表集合中就不会出现来自父类的方法信息。但同样的，有可能会出现由编译器自动添加的方法，最典型的便是类的构造器“`<clinit>`”方法和实例构造器“`<init>`”方法。

在 Java 语言中，要重载一个方法，除了要与原方法具有相同的简单名称之外，还要求必须拥有一个与原方法不同的特征签名，特征签名就是一个方法中各个参数在常量池中的字段符号引用的集合，**也就是因为返回值不会包含在特征签名中，因此 Java 语言里面是无法仅仅依靠返回值的不同来对一个已有方法进行重载的。**但是在 Class 文件格式中，特征签名的范围更大一些，只要描述符不是完全一致的两个方法也可以并存。**也就是说，如果两个方法有相同的名称和特征签名，但返回值不同，那么也是可以合法共存于同一个 Class 文件中的。**

### 属性表集合
在 Class 文件、字段表、方法表都可以携带自己的属性表集合，以用于描述某些场景专有的信息。

#### Code 属性
Code 属性是 Class 文件中最重要的一个属性，如果把一个 Java 程序中的信息分为代码和元数据两部分，那么在整个 Class 文件中，Code 属性用于描述代码，所有的其他数据项目都用于描述元数据。

**在实例方法的局部变量表中至少会存在一个指向当前对象实例的局部变量，局部变量表中也会预留出第一个 Slot 位来存放对象实例的引用，方法参数值从 1 开始计算。**

#### ConstantValue 属性
ConstantValue 属性的作用是通知虚拟机自动为静态变量赋值。**只有被 static 关键字修饰的变量（类变量）才可以使用这项属性。**

对于非 static 类型的变量（也就是实例变量）的赋值是在实例构造器 `<init>` 方法中进行的；而对于类变量，则有两种方式可以选择：在类构造器 `<clinit` 方法中或者使用 ConstantValue 属性。

![附上手稿](https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/JVM/VM-07.jpg)

## 字节码指令简介
Java 虚拟机的指令由一个字节长度的、代表着某种特定操作含义的数字（称为操作码）以及跟随其后的零至多个代表此操作所需参数（称为操作数）而构成。

### 字节码与数据类型
对于大部分与数据类型相关的字节码指令，它们的操作码助记符中都有特殊的字符来表明专门为哪种数据类型服务：i 代表对 int 类型的数据操作，l 代表 long，s 代表 short，b 代表 byte，c 代表 char，f 代表 float，d 代表 double，a 代表 reference。

大部分的指令都没有支持整数类型 byte、char 和 short，甚至没有任何指令支持 boolean 类型。编译器会在编译期或运行期将 byte 和 short 类型的数据带符号扩展为相应的 int 类型数据，将 boolean 和 char 类型数据零位扩展为相应的 int 类型数据。与之类似，在处理 boolean、byte、short 和 char 类型的数据时，也会转换为使用对应的 int 类型的字节码指令来处理。因此，大多数对于 boolean、byte、short 和 char 类型数据的操作，实际上都是使用相应的 int 类型作为运算类型。

### 加载和存储指令
加载和存储指令用于将数据在栈帧中的局部变量表和操作数栈之间来回传输，这类指令包括如下内容：

- 将一个局部变量加载到操作栈
- 将一个数值从操作数栈存储到局部变量表
- 将一个变量加载到操作数栈
- 扩充局部变量表的访问索引的指令

### 运算指令
运算或算术指令用于对两个操作数栈上的值进行某种特定运算，并把结果重新存入到操作栈顶。

大体上算术指令可以分为两种：对整型数据进行运算的指令与对浮点型数据进行运算的指令。

Java 虚拟机要求在进行浮点数运算时，所有的运算结果都必须舍入到适当的精度，非精确的结果必须舍入为可被表示的最接近的精确值，**如果有两种可表示的形式与该值一样接近，将优先选择最低有效位为零的。这种舍入模式称为向最接近数舍入模式。**

在把浮点数转换为整数时，Java 虚拟机使用向零舍入模式，这种模式的舍入结果会导致数字被截断，所有小数部分的有效字节都会被丢弃掉。**向零舍入模式将在目标数值类型中选择一个最接近但是不大于原值的数字来作为最精确的舍入结果。**

![附上手稿](https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/JVM/VM-08.jpg)

---
End. 这一章节概念的东西比较多，讲了 Class 文件中的种种。