---
title: JVM 之字节码执行引擎
date: 2018-12-01 15:47:43
categories: [开发,JVM]
tags: [Java,JVM]
---

> 代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步，却是编程语言发展的一大步。

## 概述
执行引擎是 Java 虚拟机最核心的组成部分之一。在不同的虚拟机实现里面，执行引擎在执行 Java 代码的时候可能会有解释执行（通过解释器执行）和编译执行（通过即时编译器产生本地代码执行）两种选择，也可能两者兼备，甚至还可能会包含几个不同级别的编译器执行引擎。

但从外观上看起来，所有的 Java 虚拟机的执行引擎都是一致的：**输入的是字节码文件，处理过程是字节码解析的等效过程，输出的是执行结果。**接下来将主要从 **概念模型**的角度来总结下虚拟机的 **方法调用**和 **字节码执行**。

## 运行时栈帧结构
栈帧是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈的栈元素。**每一个方法从调用开始至执行完成的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。**

每一个栈帧都包括了局部变量表、操作数栈、动态连接、方法返回地址和一些额外的附加信息。在编译程序代码的时候，栈帧中需要多大的局部变量表，多深的操作数栈都已经完全确定了，并且写入到方法表的 Code 属性之中，因此，**一个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响，而仅仅取决于具体的虚拟机实现。**

### 局部变量表
局部变量表是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。它的容量以变量槽（Variable Slot，下称 Slot）为最小单位。

在方法执行时，虚拟机是使用局部变量表来完成参数值到参数变量列表的传递过程的，如果执行的是实例方法（非 static 的方法），那局部变量表中第 0 位索引的 Slot 默认是用于传递方法所属对象实例的引用，在方法中可以通过关键字 `this` 来访问到这个隐含的参数。其余参数则按照参数表顺序排列，占用从 1 开始的局部变量 Slot，参数表分配完毕后，再根据方法体内部定义的变量顺序和作用域分配其余的 Slot。

**局部变量定义了但没有赋初始值，是不能使用的，切记！**

### 操作数栈
操作数栈也常称为操作栈，它是一个后入先出栈。同局部变量表一样，它的最大深度也是在编译时就写入到 Code 属性的 max_stacks 数据项中。

当一个方法刚刚开始执行时，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈 / 入栈操作。如：在做算术运算的时候是通过操作数栈来进行的，又或者在调用其他方法的时候是通过操作数栈来进行参数传递的。

### 动态连接
每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。

字节码中的方法调用指令就以常量池中指向方法的符号引用作为参数。这些符号引用一部分会在类加载阶段或者第一次使用的时候就转化为直接引用，这种转化称为 **静态解析**。另外一部分将在每一次运行期间转化为直接引用，这部分称为 **动态连接**。

### 方法返回地址
当一个方法开始执行后，只有两种方式可以退出这个方法：

- 执行引擎遇到任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者，是否有返回值和返回值的类型将根据遇到何种方法返回指令来决定，这种退出方法的方式称为正常完成出口。
- 在方法执行过程中遇到了异常，并且这个异常没有在方法体内得到处理，无论是 Java 虚拟机内部产生的异常还是代码中使用 `athrow` 字节码指令产生的异常，只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，这种退出方法的方式称为异常完成出口。

**一个方法使用异常完成出口的方式退出，是不会给它的上层调用者产生任何返回值的。**

方法退出的过程实际上就等同于把当前栈帧出栈，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值（如果有的话）压入调用者栈帧的操作数栈中，调整 PC 计数器的值以指向方法调用指令后面的一条指令等。

### 附加信息
虚拟机规范允许具体的虚拟机实现增加一些规范中没有描述的信息到栈帧之中，例如与调试相关的信息，这部分信息完全取决于具体的虚拟机实现。

**在实际开发中，一般会把动态连接、方法返回地址与其他附加信息全部归为一类，称为栈帧信息。**

![附上手稿](https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/JVM/VM-09.jpg)

## 方法调用
方法调用并不等同于方法执行，方法调用阶段唯一的任务就是确定被调用方法的版本（即调用哪一个方法），暂时还不涉及方法内部的具体运行过程。

**一切方法调用在 Class 文件里面存储的都只是符号引用，而不是方法在实际运行时内存布局中的入口地址（相当于之前说的直接引用）。**

### 解析
调用目标在程序代码写好、编译器进行编译时就必须确定下来。这类方法的调用称为解析。

在 Java 虚拟机里面提供了 5 条方法调用字节码指令：

- invokestatic：调用静态方法
- invokespecial：调用实例构造器 `<init>` 方法、私有方法和父类方法
- invokevirtual：调用所有的虚方法
- invokeinterface：调用接口方法，会在运行时再确定一个实现此接口的对象
- invokedynamic：先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法，在此之前的 4 条调用指令，分派逻辑是固化在 Java 虚拟机内部的，而 invokedynamic 指令的分派逻辑是由用户所设定的引导方法决定的

只要能被 invokestatic 和 invokespecial 指令调用的方法，都可以在解析阶段中确定唯一的调用版本，符合这个条件的有静态方法、私有方法、实例构造器和父类方法 4 类。它们在类加载的时候就会把符号引用解析为该方法的直接引用，称为 **非虚方法**。其余的称为 **虚方法**。

**final 方法是一种非虚方法。**

### 分派

#### 静态分派
`Human man = new Man()`

上面代码中的 `Human` 称为变量的静态类型，或是外观类型，`Man` 称为变量的实际类型。静态类型和实际类型在程序中都可以发生一些变化，但是静态类型的变化仅仅在使用时发生，变量本身的静态类型不会被改变，并且最终的静态类型是在编译期可知的；而实际类型变化的结果在运行期才可确定，编译器在编译程序时并不知道一个对象的实际类型是什么。

**编译器在重载时是通过参数的静态类型而不是实际类型作为判断依据的，所以，两个静态类型相同但实际类型不同的变量，在编译阶段，Javac 编译器会根据参数的静态类型决定使用哪一个重载版本。**

#### 动态分派
我们先说说重写，重写与动态分派关系密切。invokevirtual 指令执行是在 **运行期**确定接收者的实际类型，所以调用中的 invokevirtual 指令把常量池中的类方法符号引用解析到了不同的直接引用上，这个过程就是 Java 语言中方法重写的本质。

我们把这种在运行期根据实际类型确定方法执行版本的分派过程称为动态分派。

![附上手稿](https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/JVM/VM-10.jpg)

#### 单分派与多分派
方法的接收者与方法的参数统称为方法的宗量，根据分派基于多少种宗量，可以将分派划分为单分派和多分派两种。

单分派是根据一个宗量对目标方法进行选择，多分派是根据多于一个宗量对目标方法进行选择。

## 基于栈的字节码解释执行引擎
探讨虚拟机是如何执行方法中的字节码指令的。

### 解释执行
![编译过程](https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/JVM/JVM-Compilation-Process.png)

Java 语言中，Javac 编译器完成了程序代码经过词法分析、语法分析到抽象语法树，再遍历语法树生成线性的字节码指令流的过程。因为这一部分动作是在 Java 虚拟机之外进行的，而解释器在虚拟机的内部，所以 Java 程序的编译就是半独立的实现。

### 基于栈的指令集与基于寄存器的指令集
基于栈的指令集主要优点就是可移植，还可把一些访问频繁的数据放到寄存器中获取尽量好的性能，代码会相对更加紧凑，编译器实现更加简单等。

栈架构指令集的主要缺点是执行速度相对来说会稍慢一些，完成相同功能所需的指令数量较寄存器架构多，频繁的栈访问导致频繁的内存访问。

---
End.