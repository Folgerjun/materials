---
title: LeetCode 之最长公共前缀（Longest Common Prefix）
date: 2018-11-14 13:23:51
categories: [开发,算法]
tags: [Java,算法,LeetCode]
---

潜意识还没养成的我在思考问题方面总会出点岔子，老是走一些弯路。虽说结果可能是一样的，过程却是复杂许多，这也是我为什么决定要好好刷一遍 leetcode 中的题目的原因。数学就在于简单之美，一些看似异常复杂的问题可以巧妙地通过分治从而完美解决，很能锻炼人的逻辑思维能力，这也是我想要的。

下面来看问题的描述：
```
编写一个函数来查找字符串数组中的最长公共前缀。

如果不存在公共前缀，返回空字符串 ""。

示例 1:

输入: ["flower","flow","flight"]
输出: "fl"
示例 2:

输入: ["dog","racecar","car"]
输出: ""
解释: 输入不存在公共前缀。
说明:

所有输入只包含小写字母 a-z 。
```

问题看似很简单，查找字符串数组中每个元素的最长公共前缀。

确实简单，我这个莽夫的第一想法就是遍历暴力分析。两个循环能解决，问题是不大，但是很不优雅，看着就难受。

虽说“黑猫白猫，能抓老鼠的就是好猫”，但是两猫都能抓老鼠，那我当然还是喜欢高颜值猫了！

随后我就去官网找到了我要的答案：
```
    /**
     * 官网解法
     * 
     * @param strs
     * @return
     */
    public static String longestCommonPrefix1(String[] strs) {
        if (strs.length == 0)
            return "";
        String prefix = strs[0]; // 以第一个字符串为基准
        for (int i = 1; i < strs.length; i++)
            while (strs[i].indexOf(prefix) != 0) { // 依次找到均满足的相同起始字符
                prefix = prefix.substring(0, prefix.length() - 1);
                if (prefix.isEmpty())
                    return "";
            }
        return prefix;
    }
```

这一种是我觉得最好理解最满意的一种解法。

这里以第一个元素为基准值，挨个与其它元素进行比较。while 循环里面就是为了使基准值成为比较元素的起始字符串，故它不满足就每次截掉最后一位。若是全部截完了那就是无公共前缀了。

这完美体现了分而治之，将所有元素的比较变成了两个元素之间的比较，可以节省其运行时间同时也使得代码更好理解更加优雅。

学习了，牢记。